<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v5.16.3"><title>The CString Class - 3</title></head> <body> <h1>The CString Class - 3</h1>  <p><em>COM and CString</em></p> <p>2025-12-03</p> <p>Written by: xiaobin</p> <h3 id="cstring-to-bstr">CString to BSTR</h3>
<p>When programming with ActiveX, you will sometimes need a value represented as a type BSTR.
A BSTR is a counted string, a wide-character (Unicode) string on Intel platforms and can contain embedded NUL characters.</p>
<p>You can convert at CString to a BSTR by calling the CString method AllocSysString:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>CString s;</span></span>
<span class="line"><span>s = ... ; // whatever</span></span>
<span class="line"><span>BSTR b = s.AllocSysString();</span></span></code></pre>
<p>The pointer b points to a newly-allocated BSTR object which is a copy of the CString, including the terminal NUL character.
This may now be passed to whatever interface you are calling that requires a BSTR.
Normally, a BSTR is disposed of by the component receiving it. If you should need to dispose of a BSTR, you must use the call</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>::SysFreeString(b);</span></span></code></pre>
<p>to free the string.</p>
<p>The story is that the decision of how to represent strings sent to ActiveX controls resulted in some serious turf wars within Microsoft.
The Visual Basic people won, and the string type BSTR (acronym for “Basic String”) was the result.</p>
<h3 id="bstr-to-cstring">BSTR to CString</h3>
<p>Since a BSTR is a counted Unicode string, you can use standard conversions to make an 8-bit CString.
Actually, this is built-in; there are special constructors for converting ANSI strings to Unicode and vice-versa.
You can also get BSTRs as results in a VARIANT type, which is a type returned by various COM and Automation calls.</p>
<p>For example, if you do, in an ANSI application,</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>BSTR b;</span></span>
<span class="line"><span>b = ...; // whatever</span></span>
<span class="line"><span>CString s(b == NULL ? L"" : b)</span></span></code></pre>
<p>works just fine for a single-string BSTR,
because there is a special constructor that takes an LPCWSTR (which is what a BSTR is) and converts it to an ANSI string.
The special test is required because a BSTR could be NULL,
and the constructors Don’t Play Well with NULL inputs (thanks to Brian Ross for pointing this out!).
This also only works for a BSTR that contains only a single string terminated with a NUL;
you have to do more work to convert strings that contain multiple NUL characters.
Note that embedded NUL characters generally don’t work well in CStrings and generally should be avoided.</p>
<p>Remember, according to the rules of C/C++, if you have an LPWSTR it will match a parameter type of LPCWSTR (it doesn’t work the other way!).</p>
<p>In UNICODE mode, this is just the constructor</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>CString::CString(LPCTSTR);</span></span></code></pre>
<p>As indicated above, in ANSI mode there is a special constructor for</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>CString::CString(LPCWSTR);</span></span></code></pre>
<p>this calls an internal function to convert the Unicode string to an ANSI string.
(In Unicode mode there is a special constructor that takes an LPCSTR, a pointer to an 8-bit ANSI string, and widens it to a Unicode string!).
Again, note the limitation imposed by the need to test for a BSTR value which is NULL.</p>
<p>There is an additional problem as pointed out above: BSTRs can contain embedded NUL characters;
CString constructors can only handle single NUL characters in a string.
This means that CStrings will compute the wrong length for a string which contains embedded NUL bytes.
You need to handle this yourself. If you look at the constructors in strcore.cpp,
you will see that they all do an lstrlen or equivalent to compute the length.</p>
<p>Note that the conversion from Unicode to ANSI uses the ::WideCharToMultiByte conversion with specific arguments that you may not like.
If you want a different conversion than the default, you have to write your own.
If you are compiling as UNICODE, then it is a simple assignment:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>CString convert(BSTR b)</span></span>
<span class="line"><span>   {</span></span>
<span class="line"><span>    if(b == NULL)</span></span>
<span class="line"><span>        return CString(_T(""));</span></span>
<span class="line"><span>    CString s(b); // in UNICODE mode</span></span>
<span class="line"><span>    return s;</span></span>
<span class="line"><span>   }</span></span></code></pre>
<p>If you are in ANSI mode, you need to convert the string in a more complex fashion.
This will accomplish it. Note that this code uses the same argument values to ::WideCharToMultiByte that the implicit constructor for CString uses,
so you would use this technique only if you wanted to change these parameters to do the conversion in some other fashion,
for example, specifying a different default character, a different set of flags, etc.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>CString convert(BSTR b)</span></span>
<span class="line"><span>   {</span></span>
<span class="line"><span>    CString s;</span></span>
<span class="line"><span>    if(b == NULL)</span></span>
<span class="line"><span>       return s; // empty for NULL BSTR</span></span>
<span class="line"><span>#ifdef UNICODE</span></span>
<span class="line"><span>    s = b;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    LPSTR p = s.GetBuffer(SysStringLen(b) + 1); </span></span>
<span class="line"><span>    ::WideCharToMultiByte(CP_ACP,            // ANSI Code Page</span></span>
<span class="line"><span>                          0,                 // no flags</span></span>
<span class="line"><span>                          b,                 // source widechar string</span></span>
<span class="line"><span>                          -1,                // assume NUL-terminated</span></span>
<span class="line"><span>                          p,                 // target buffer</span></span>
<span class="line"><span>                          SysStringLen(b)+1, // target buffer length</span></span>
<span class="line"><span>                          NULL,              // use system default char</span></span>
<span class="line"><span>                          NULL);             // don't care if default used</span></span>
<span class="line"><span>    s.ReleaseBuffer();</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    return s;</span></span>
<span class="line"><span>   }</span></span></code></pre>
<p>Note that I do not worry about what happens if the BSTR contains Unicode characters that do not map to the 8-bit character set,
because I specify NULL as the last two parameters. This is the sort of thing you might want to change.</p>
<h3 id="variant-to-cstring">VARIANT to CString</h3>
<p>A VARIANT is a generic parameter/return type in COM programming.
You can write methods that return a type VARIANT,
and which type the function returns may (and often does) depend on the input parameters to your method (for example,
in Automation, depending on which method you call,
IDispatch::Invoke may return (via one of its parameters) a VARIANT which holds a BYTE, a WORD, an float, a double, a date, a BSTR,
and about three dozen other types (see the specifications of the VARIANT structure in the MSDN).
In the example below, it is assumed that the type is known to be a variant of type BSTR,
which means that the value is found in the string referenced by bstrVal.
This takes advantage of the fact that there is a constructor which, in an ANSI application,
will convert a value referenced by an LPCWCHAR to a CString (see BSTR-to-CString).
In Unicode mode, this turns out to be the normal CString constructor.
See the caveats about the default ::WideCharToMultibyte conversion and whether or not you find these acceptable (mostly, you will).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>VARIANT vaData;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vaData = m_com.YourMethodHere();</span></span>
<span class="line"><span>ASSERT(vaData.vt == VT_BSTR);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CString strData(vaData.bstrVal);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Note that you could also make a more generic conversion routine that looked at the vt field. In this case, you might consider something like:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CString VariantToString(VARIANT * va)</span></span>
<span class="line"><span>   {</span></span>
<span class="line"><span>    CString s;</span></span>
<span class="line"><span>    switch(va->vt)</span></span>
<span class="line"><span>      { /* vt */</span></span>
<span class="line"><span>       case VT_BSTR:</span></span>
<span class="line"><span>          return CString(vaData->bstrVal);</span></span>
<span class="line"><span>       case VT_BSTR | VT_BYREF:</span></span>
<span class="line"><span>          return CString(*vaData->pbstrVal);</span></span>
<span class="line"><span>       case VT_I4:</span></span>
<span class="line"><span>          s.Format(_T("%d"), va->lVal);</span></span>
<span class="line"><span>          return s;</span></span>
<span class="line"><span>       case VT_I4 | VT_BYREF:</span></span>
<span class="line"><span>          s.Format(_T("%d"), *va->plVal);</span></span>
<span class="line"><span>       case VT_R8:</span></span>
<span class="line"><span>          s.Format(_T("%f"), va->dblVal);</span></span>
<span class="line"><span>          return s;</span></span>
<span class="line"><span>       ... remaining cases left as an Exercise For The Reader</span></span>
<span class="line"><span>       default:</span></span>
<span class="line"><span>          ASSERT(FALSE); // unknown VARIANT type (this ASSERT is optional)</span></span>
<span class="line"><span>          return CString("");</span></span>
<span class="line"><span>      } /* vt */</span></span>
<span class="line"><span>   }</span></span></code></pre>
<h2 id="ref">Ref</h2>
<ul>
<li><a href="http://www.flounder.com/cstring.htm">CString Management</a></li>
</ul>  <footer> <a href="https://tdtc-hrb.github.io/blog-frontend">blog-frontend</a> <a href="https://tdtc-hrb.github.io/com-vc">com-vc</a> <a href="https://tdtc-hrb.github.io/css-tws">css-tws</a> <a href="https://tdtc-hrb.github.io/ops-win">ops-win</a> </footer> </body></html>